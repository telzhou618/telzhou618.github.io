<!doctype html>



































<html
  class="not-ready lg:text-base"
  style="--bg: #faf8f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Redis 从入门到入土 - Home</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="Redis 是什么 Redis 是一个高性能的基于内存实现的K-V存储数据库 。
Redis 的优点 性能极高，Redis能读的速度是110000次/s,写的速度是81000次/s 。 支持持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 多种数据类型，同时还提供list，set，zset，hash等数据结构的存储。 支持主从复制，自动同步，可实现读写分离。 丰富的特性，支持pub/sub，key过期策略，事务，支持多个DB等。 Redis 的缺点 基于内存存储，单机容量有限。 重启会加载磁盘缓存到内存，这期间不能提供服务。 主从复制采用全量复制，这个过程会占用更多内存和网络资源。 Redis 应用场景 缓存数据，常见应用。
计数器，单线程可避免并发，保证不出错，性能毫秒级。
队列，可作为简单消息队列使用。
分布式锁与单线程机制
位操作，如统计在线列表
最新列表，获取最新10条新闻数据
排行榜，消费排行榜
Redis 基础 Redis 下载安装安装 从源码安装
# download wget https://download.redis.io/releases/redis-6.2.5.tar.gz tar xzf redis-6.2.5.tar.gz cd redis-6.2.5 make # run redis-server src/redis-server # test src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &#34;bar&#34; Ubuntu 安装
sudo add-apt-repository ppa:redislabs/redis sudo apt-get update sudo apt-get install redis Mac 安装" />
  <meta name="author" content="telzhou618" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://telzhou618.github.io/main.min.css" />

  
  
  
  
  
  <link rel="preload" as="image" href="https://telzhou618.github.io/theme.svg" />

  
  
  
  
  <link rel="preload" as="image" href="https://s.gravatar.com/avatar/9ff9514e4c37a5cb11be475190289857778d613942c4d6364c16e770a4cb66a0?s=80" />
  
  

  
  
  <link rel="preload" as="image" href="https://telzhou618.github.io/github.svg" />
  
  

  
  

  
  
  
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
  integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
  crossorigin="anonymous"
/>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
  integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
  crossorigin="anonymous"
></script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js"
  integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
  crossorigin="anonymous"
></script>

<script>
  document.addEventListener('DOMContentLoaded', () =>
    renderMathInElement(document.body, {
      
      
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
      ],
      
      throwOnError: false,
    }),
  );
</script>

  
  
  

  
  <link rel="icon" href="https://telzhou618.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://telzhou618.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.121.1">

  
  
  
  
  
  <meta itemprop="name" content="Redis 从入门到入土">
<meta itemprop="description" content="Redis 是什么 Redis 是一个高性能的基于内存实现的K-V存储数据库 。
Redis 的优点 性能极高，Redis能读的速度是110000次/s,写的速度是81000次/s 。 支持持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 多种数据类型，同时还提供list，set，zset，hash等数据结构的存储。 支持主从复制，自动同步，可实现读写分离。 丰富的特性，支持pub/sub，key过期策略，事务，支持多个DB等。 Redis 的缺点 基于内存存储，单机容量有限。 重启会加载磁盘缓存到内存，这期间不能提供服务。 主从复制采用全量复制，这个过程会占用更多内存和网络资源。 Redis 应用场景 缓存数据，常见应用。
计数器，单线程可避免并发，保证不出错，性能毫秒级。
队列，可作为简单消息队列使用。
分布式锁与单线程机制
位操作，如统计在线列表
最新列表，获取最新10条新闻数据
排行榜，消费排行榜
Redis 基础 Redis 下载安装安装 从源码安装
# download wget https://download.redis.io/releases/redis-6.2.5.tar.gz tar xzf redis-6.2.5.tar.gz cd redis-6.2.5 make # run redis-server src/redis-server # test src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &#34;bar&#34; Ubuntu 安装
sudo add-apt-repository ppa:redislabs/redis sudo apt-get update sudo apt-get install redis Mac 安装"><meta itemprop="datePublished" content="2023-06-28T14:44:07+08:00" />
<meta itemprop="dateModified" content="2023-06-28T14:44:07+08:00" />
<meta itemprop="wordCount" content="1336">
<meta itemprop="keywords" content="" />
  
  <meta property="og:title" content="Redis 从入门到入土" />
<meta property="og:description" content="Redis 是什么 Redis 是一个高性能的基于内存实现的K-V存储数据库 。
Redis 的优点 性能极高，Redis能读的速度是110000次/s,写的速度是81000次/s 。 支持持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 多种数据类型，同时还提供list，set，zset，hash等数据结构的存储。 支持主从复制，自动同步，可实现读写分离。 丰富的特性，支持pub/sub，key过期策略，事务，支持多个DB等。 Redis 的缺点 基于内存存储，单机容量有限。 重启会加载磁盘缓存到内存，这期间不能提供服务。 主从复制采用全量复制，这个过程会占用更多内存和网络资源。 Redis 应用场景 缓存数据，常见应用。
计数器，单线程可避免并发，保证不出错，性能毫秒级。
队列，可作为简单消息队列使用。
分布式锁与单线程机制
位操作，如统计在线列表
最新列表，获取最新10条新闻数据
排行榜，消费排行榜
Redis 基础 Redis 下载安装安装 从源码安装
# download wget https://download.redis.io/releases/redis-6.2.5.tar.gz tar xzf redis-6.2.5.tar.gz cd redis-6.2.5 make # run redis-server src/redis-server # test src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &#34;bar&#34; Ubuntu 安装
sudo add-apt-repository ppa:redislabs/redis sudo apt-get update sudo apt-get install redis Mac 安装" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://telzhou618.github.io/post/redis/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-06-28T14:44:07+08:00" />
<meta property="article:modified_time" content="2023-06-28T14:44:07+08:00" />


  
  <meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Redis 从入门到入土"/>
<meta name="twitter:description" content="Redis 是什么 Redis 是一个高性能的基于内存实现的K-V存储数据库 。
Redis 的优点 性能极高，Redis能读的速度是110000次/s,写的速度是81000次/s 。 支持持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 多种数据类型，同时还提供list，set，zset，hash等数据结构的存储。 支持主从复制，自动同步，可实现读写分离。 丰富的特性，支持pub/sub，key过期策略，事务，支持多个DB等。 Redis 的缺点 基于内存存储，单机容量有限。 重启会加载磁盘缓存到内存，这期间不能提供服务。 主从复制采用全量复制，这个过程会占用更多内存和网络资源。 Redis 应用场景 缓存数据，常见应用。
计数器，单线程可避免并发，保证不出错，性能毫秒级。
队列，可作为简单消息队列使用。
分布式锁与单线程机制
位操作，如统计在线列表
最新列表，获取最新10条新闻数据
排行榜，消费排行榜
Redis 基础 Redis 下载安装安装 从源码安装
# download wget https://download.redis.io/releases/redis-6.2.5.tar.gz tar xzf redis-6.2.5.tar.gz cd redis-6.2.5 make # run redis-server src/redis-server # test src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &#34;bar&#34; Ubuntu 安装
sudo add-apt-repository ppa:redislabs/redis sudo apt-get update sudo apt-get install redis Mac 安装"/>

  
  
  
  <link rel="canonical" href="https://telzhou618.github.io/post/redis/" />
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold"
      href="https://telzhou618.github.io"
      >Home</a
    >
    <div
      class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    
    <nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6">
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/post/"
        >Posts</a
      >
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/about/"
        >About</a
      >
      
    </nav>
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/telzhou618"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"
    >
      

<article>
  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">Redis 从入门到入土</h1>

    
    <div class="text-sm antialiased opacity-60">
      
      <time>Jun 28, 2023</time>
      
      
      
      
    </div>
    
  </header>

  <section><p><img src="https://raw.githubusercontent.com/telzhou618/images/main/img01/1*1gUAG0m0infLs92uSpw9nA.png" alt="img"></p>
<h2 id="redis-是什么">Redis 是什么</h2>
<p>Redis 是一个高性能的基于内存实现的K-V存储数据库 。</p>
<h2 id="redis-的优点">Redis 的优点</h2>
<ul>
<li>性能极高，Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>支持持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>多种数据类型，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>支持主从复制，自动同步，可实现读写分离。</li>
<li>丰富的特性，支持pub/sub，key过期策略，事务，支持多个DB等。</li>
</ul>
<h2 id="redis-的缺点">Redis 的缺点</h2>
<ul>
<li>基于内存存储，单机容量有限。</li>
<li>重启会加载磁盘缓存到内存，这期间不能提供服务。</li>
<li>主从复制采用全量复制，这个过程会占用更多内存和网络资源。</li>
</ul>
<h2 id="redis-应用场景">Redis 应用场景</h2>
<ul>
<li>
<p>缓存数据，常见应用。</p>
</li>
<li>
<p>计数器，单线程可避免并发，保证不出错，性能毫秒级。</p>
</li>
<li>
<p>队列，可作为简单消息队列使用。</p>
</li>
<li>
<p>分布式锁与单线程机制</p>
</li>
<li>
<p>位操作，如统计在线列表</p>
</li>
<li>
<p>最新列表，获取最新10条新闻数据</p>
</li>
<li>
<p>排行榜，消费排行榜</p>
</li>
</ul>
<h2 id="redis-基础">Redis 基础</h2>
<h3 id="redis-下载安装安装">Redis 下载安装安装</h3>
<p>从源码安装</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># download</span>
</span></span><span style="display:flex;"><span>wget https://download.redis.io/releases/redis-6.2.5.tar.gz
</span></span><span style="display:flex;"><span>tar xzf redis-6.2.5.tar.gz
</span></span><span style="display:flex;"><span>cd redis-6.2.5
</span></span><span style="display:flex;"><span>make
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># run redis-server</span>
</span></span><span style="display:flex;"><span>src/redis-server
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># test</span>
</span></span><span style="display:flex;"><span>src/redis-cli
</span></span><span style="display:flex;"><span>redis&gt; set foo bar
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>redis&gt; get foo
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;bar&#34;</span>
</span></span></code></pre></div><p>Ubuntu 安装</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo add-apt-repository ppa:redislabs/redis
</span></span><span style="display:flex;"><span>sudo apt-get update
</span></span><span style="display:flex;"><span>sudo apt-get install redis
</span></span></code></pre></div><p>Mac 安装</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>brew install redis
</span></span></code></pre></div><h3 id="jedis-链接redis">Jedis 链接Redis</h3>
<p>先引入jar包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;groupId&gt;</span>redis.clients<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;artifactId&gt;</span>jedis<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;version&gt;</span>2.9.0<span style="color:#f92672">&lt;/version&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>JAVA 代码调用实例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">JedisSingleTest</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    JedisPoolConfig jedisPoolConfig <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> JedisPoolConfig();
</span></span><span style="display:flex;"><span>    jedisPoolConfig.<span style="color:#a6e22e">setMaxTotal</span>(20);
</span></span><span style="display:flex;"><span>    jedisPoolConfig.<span style="color:#a6e22e">setMaxIdle</span>(10);
</span></span><span style="display:flex;"><span>    jedisPoolConfig.<span style="color:#a6e22e">setMinIdle</span>(5);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// timeout，这里既是连接超时又是读写超时，从Jedis 2.8开始有区分connectionTimeout和soTimeout的构造函数</span>
</span></span><span style="display:flex;"><span>    JedisPool jedisPool <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> JedisPool(jedisPoolConfig, <span style="color:#e6db74">&#34;192.168.0.60&#34;</span>, 6379, 3000, <span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>    Jedis jedis <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//从redis连接池里拿出一个连接执行命令</span>
</span></span><span style="display:flex;"><span>      jedis <span style="color:#f92672">=</span> jedisPool.<span style="color:#a6e22e">getResource</span>();
</span></span><span style="display:flex;"><span>      System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(jedis.<span style="color:#a6e22e">set</span>(<span style="color:#e6db74">&#34;single&#34;</span>, <span style="color:#e6db74">&#34;zhuge&#34;</span>));
</span></span><span style="display:flex;"><span>      System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(jedis.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;single&#34;</span>));
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>      e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (jedis <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>        jedis.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="redis-管道pipeline使用">Redis 管道（Pipeline）使用</h3>
<p>管道可以一次发送多个命令给Redis服务，减少网络开销，如果前面的命令执行失败，后面的命令会继续执行，不会被影响，最后把所有命令的执行结果一次返回。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Pipeline pl <span style="color:#f92672">=</span> jedis.<span style="color:#a6e22e">pipelined</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 10; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    pl.<span style="color:#a6e22e">incr</span>(<span style="color:#e6db74">&#34;pipelineKey&#34;</span>);
</span></span><span style="display:flex;"><span>    pl.<span style="color:#a6e22e">set</span>(<span style="color:#e6db74">&#34;zhuge&#34;</span> <span style="color:#f92672">+</span> i, <span style="color:#e6db74">&#34;zhuge&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//模拟管道报错</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// pl.setbit(&#34;zhuge&#34;, -1, true);</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> results <span style="color:#f92672">=</span> pl.<span style="color:#a6e22e">syncAndReturnAll</span>();
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(results);
</span></span></code></pre></div><h3 id="redis-lua-脚本使用">Redis Lua 脚本使用</h3>
<p>LUA 脚本可以代替Redis的事务执行，要么所有命令都执行成功，要么都失败，是原子性的，也可以减少网络开销。</p>
<p>在Redis控制台执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>127.0.0.1:6379&gt; eval <span style="color:#e6db74">&#34;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&#34;</span> <span style="color:#ae81ff">2</span> key1 key2 first second
</span></span><span style="display:flex;"><span>1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key1&#34;</span>
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key2&#34;</span>
</span></span><span style="display:flex;"><span>3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;first&#34;</span>
</span></span><span style="display:flex;"><span>4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;second&#34;</span>
</span></span></code></pre></div><p>在代码中使用：</p>
<p>模拟减库存操作，如果后面执行失败，减掉的库存会回滚。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>jedis.<span style="color:#a6e22e">set</span>(<span style="color:#e6db74">&#34;product_stock_10016&#34;</span>, <span style="color:#e6db74">&#34;15&#34;</span>);  <span style="color:#75715e">//初始化商品10016的库存</span>
</span></span><span style="display:flex;"><span>String script <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; local count = redis.call(&#39;get&#39;, KEYS[1]) &#34;</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34; local a = tonumber(count) &#34;</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34; local b = tonumber(ARGV[1]) &#34;</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34; if a &gt;= b then &#34;</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;   redis.call(&#39;set&#39;, KEYS[1], a-b) &#34;</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;   return 1 &#34;</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34; end &#34;</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34; return 0 &#34;</span>;
</span></span><span style="display:flex;"><span>Object obj <span style="color:#f92672">=</span> jedis.<span style="color:#a6e22e">eval</span>(script, Arrays.<span style="color:#a6e22e">asList</span>(<span style="color:#e6db74">&#34;product_stock_10016&#34;</span>), Arrays.<span style="color:#a6e22e">asList</span>(<span style="color:#e6db74">&#34;10&#34;</span>));
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(obj);
</span></span></code></pre></div><h3 id="redis-key-淘汰策略">Redis Key 淘汰策略</h3>
<p>Redis缓存达到最大内存限制时会执行淘汰策略，如下命令设置最大内存。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>maxmemory 100mb
</span></span></code></pre></div><p>如下配置key淘汰策略，默认noeviction（拒绝请求）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>maxmemory-policy noeviction
</span></span></code></pre></div><p>全部配置参数：</p>
<ul>
<li><strong>noeviction</strong>  达到内存限制时返回错误，直接拒绝，del命令除外，是Redis的默认策略。</li>
<li><strong>allkeys-lru</strong> 尝试删除最近最少使用的，也就是优先驱逐最长时间没使用的。</li>
<li><strong>volatile-lru</strong> 尝试删除最近最少的使用的，但仅限设置了过期时间的key。</li>
<li><strong>allkeys-random</strong> 随机驱逐key。</li>
<li><strong>volatile-random</strong> 随机驱逐key, 但仅限设置了过期时间的key。</li>
<li><strong>volatile-ttl</strong> 驱逐设置了过期时间的key, 优先驱逐生存期较短的。</li>
<li><strong>allkeys-lfu</strong> 优先驱逐最近最不常使用的，也就是优先驱逐一定时间内使用次数最少的，4.1 新增的。</li>
<li><strong>volatile-lfu</strong> 优先驱逐最近最不常使用的，但仅限设置了过期时间的key，4.1 新增的。</li>
</ul>
<h3 id="redis-批量插入海量数据">Redis 批量插入海量数据</h3>
<p>假如用一条条执行 SET的方式插入百万级的数据量，虽然每条命令执行很快，但是网络来来回回折腾带来的开销也不容小觑，为了执行海量数据批量导入，可以结合redis管道完成。</p>
<p>首先将要导入的数据以命令的方式写入到文件中，如下：</p>
<p>/tmp/big-data.txt</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>SET name zhangsan
</span></span><span style="display:flex;"><span>SET name1 lisi
</span></span><span style="display:flex;"><span>SET name2 wangwu
</span></span><span style="display:flex;"><span>SET name3 zhaoliu
</span></span></code></pre></div><p>然后执行以下命令导入</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat big-data.txt | redis-cli --pipe
</span></span></code></pre></div><p>执行结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>All data transferred. Waiting <span style="color:#66d9ef">for</span> the last reply...
</span></span><span style="display:flex;"><span>Last reply received from server.
</span></span><span style="display:flex;"><span>errors: 0, replies: <span style="color:#ae81ff">1000000</span>
</span></span></code></pre></div><h3 id="redis-遍历所有元素">Redis 遍历所有元素</h3>
<ul>
<li><strong>keys * 遍历</strong></li>
</ul>
<p>keys * 会一次返回匹配到的所有key, 当数据量大时要慎用，避免阻塞redis。</p>
<p>实例1：查询所有的key</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>127.0.0.1:6379&gt; keys *
</span></span><span style="display:flex;"><span>1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name3&#34;</span>
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name1&#34;</span>
</span></span><span style="display:flex;"><span>3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name2&#34;</span>
</span></span><span style="display:flex;"><span>4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name&#34;</span>
</span></span></code></pre></div><p>实例2：查询所有前缀为name的key</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>127.0.0.1:6379&gt; keys name*
</span></span><span style="display:flex;"><span>1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name3&#34;</span>
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name1&#34;</span>
</span></span><span style="display:flex;"><span>3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name2&#34;</span>
</span></span><span style="display:flex;"><span>4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name&#34;</span>
</span></span></code></pre></div><ul>
<li><strong>scan 渐进式遍历</strong></li>
</ul>
<p>scan 遍历可以做到分页遍历，数据量大是比较合适，每次请求会返回下次一的游标，直达游标为0结束，但是在遍历过程中如果有key新增或删除可能出现新重复数据等情况，使用时要注意。</p>
<p>命令格式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>SCAN cursor <span style="color:#f92672">[</span>MATCH pattern<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>COUNT count<span style="color:#f92672">]</span> 
</span></span></code></pre></div><p>实例：扫描key前缀为name的元素，每次返回2条。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>127.0.0.1:6379&gt; scan <span style="color:#ae81ff">0</span> match name* count <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1&#34;</span>
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">)</span> 1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name3&#34;</span>
</span></span><span style="display:flex;"><span>   2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name2&#34;</span>
</span></span><span style="display:flex;"><span>   3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name&#34;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>127.0.0.1:6379&gt; scan <span style="color:#ae81ff">1</span> match name* count <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;0&#34;</span>
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">)</span> 1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;name1&#34;</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt;
</span></span></code></pre></div><blockquote>
<p>当返回的 cursor 为0时结束。</p>
</blockquote>
<h2 id="redis-持久化方案">Redis 持久化方案</h2>
<h3 id="持久化之rdb-模式">持久化之rdb 模式</h3>
<p>根据配置规则redis 会以生生二进制文件dump.rdb的方式持久化数据到磁盘，每次持久化会生成一个新的文件覆盖旧的文件，默认是开启的，配置方法如下所示。</p>
<p><strong>开启rdb模式</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>save <span style="color:#ae81ff">900</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>save <span style="color:#ae81ff">300</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>save <span style="color:#ae81ff">60</span> <span style="color:#ae81ff">10000</span> <span style="color:#75715e"># 60s内有10000个key被改动则触发rdb持久化</span>
</span></span></code></pre></div><p>关闭RDB只需要将所有的save保存策略注释掉即可。</p>
<p>还可以手动执行命令生成RDB快照，进入redis客户端执行命令<strong>save</strong>或<strong>bgsave</strong>可以生成dump.rdb文件， 每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。save 会同步执行，阻塞客户端的操作，bgsave会fork一个子进程处理异步处理。</p>
<h3 id="持久化之aof模式">持久化之aof模式</h3>
<p>aof 是以记类似日志的方式持久化，默认是关闭的，需要执行以下命令开启。</p>
<p><strong>开启aof模式</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>appendonly yes
</span></span></code></pre></div><p><strong>aof 策略配置</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>appendfsync always <span style="color:#75715e"># 每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</span>
</span></span><span style="display:flex;"><span>appendfsync everysec <span style="color:#75715e"># 每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。</span>
</span></span><span style="display:flex;"><span>appendfsync no <span style="color:#75715e"># 从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</span>
</span></span></code></pre></div><p><strong>aof 重写</strong></p>
<p>多次修改同一个key的值后，经过aof重写会只保留最后一次修改的命令，这样可以保持aof文件只保留有效的命且减少占用存储空间，默认自动开启。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>auto-aof-rewrite-percentage <span style="color:#ae81ff">100</span>  <span style="color:#75715e"># aof文件自上一次重写后文件大小增长了100%则再次触发重写</span>
</span></span><span style="display:flex;"><span>auto-aof-rewrite-min-size 64mb   <span style="color:#75715e"># aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就 很快，重写的意义不大</span>
</span></span></code></pre></div><h2 id="redis-主从模式">Redis 主从模式</h2>
<p><img src="https://raw.githubusercontent.com/telzhou618/images/main/img01/2adbc6e661eb44a2add519bb590e86e5%7Etplv-k3u1fbpfcp-watermark.image" alt="redis主从"></p>
<h3 id="主从模式配置">主从模式配置</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>1、复制一份redis.conf文件
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>2、将相关配置修改为如下值：
</span></span><span style="display:flex;"><span>port <span style="color:#ae81ff">6380</span>
</span></span><span style="display:flex;"><span>pidfile /var/run/redis_6380.pid  <span style="color:#75715e"># 把pid进程号写入pidfile配置的文件</span>
</span></span><span style="display:flex;"><span>logfile <span style="color:#e6db74">&#34;6380.log&#34;</span>
</span></span><span style="display:flex;"><span>dir /usr/local/redis-5.0.3/data/6380  <span style="color:#75715e"># 指定数据存放目录</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 需要注释掉bind</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># bind 127.0.0.1（bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可）</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>3、配置主从复制
</span></span><span style="display:flex;"><span>replicaof 192.168.0.60 <span style="color:#ae81ff">6379</span>   <span style="color:#75715e"># 从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</span>
</span></span><span style="display:flex;"><span>replica-read-only yes  <span style="color:#75715e"># 配置从节点只读</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>4、启动从节点
</span></span><span style="display:flex;"><span>redis-server redis.conf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>5、连接从节点
</span></span><span style="display:flex;"><span>redis-cli -p <span style="color:#ae81ff">6380</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>6、测试在6379实例上写数据，6380实例是否能及时同步新修改数据
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>7、可以自己再配置一个6381的从节点
</span></span></code></pre></div><h3 id="主从工作原理">主从工作原理</h3>
<p>如果你为master配置了一个slave，不管这个slave是否是第一次连接上Master，它都会发送一个<strong>PSYNC</strong>命令给master请求复制数据。</p>
<p>master收到PSYNC命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件，持久化期间，master会继续接收客户端的请求，它会把这些可能修改数据集的请求缓存在内存中。当持久化进行完毕以后，master会把这份rdb文件数据集发送给slave，slave会把接收到的数据进行持久化生成rdb，然后再加载到内存中。然后，master再将之前缓存在内存中的命令发送给slave。</p>
<p>当master与slave之间的连接由于某些原因而断开时，slave能够自动重连Master，如果master收到了多个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的slave。</p>
<h3 id="主从模式的缺点">主从模式的缺点</h3>
<p>无法实现自动故障转移，主节点挂了从节点需要手动顶上去。</p>
<h2 id="redis-哨兵模式">Redis 哨兵模式</h2>
<p>sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。 哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis 主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</p>
<p><img src="https://raw.githubusercontent.com/telzhou618/images/main/img01/16560ce647c2583e%7Etplv-t2oaga2asx-watermark.image" alt="Redis哨兵"></p>
<h3 id="redis-哨兵架构搭建步骤"><strong>redis 哨兵架构搭建步骤</strong></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>1、复制一份sentinel.conf文件
</span></span><span style="display:flex;"><span>cp sentinel.conf sentinel-26379.conf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>2、将相关配置修改为如下值：
</span></span><span style="display:flex;"><span>port <span style="color:#ae81ff">26379</span>
</span></span><span style="display:flex;"><span>daemonize yes
</span></span><span style="display:flex;"><span>pidfile <span style="color:#e6db74">&#34;/var/run/redis-sentinel-26379.pid&#34;</span>
</span></span><span style="display:flex;"><span>logfile <span style="color:#e6db74">&#34;26379.log&#34;</span>
</span></span><span style="display:flex;"><span>dir <span style="color:#e6db74">&#34;/usr/local/redis-5.0.3/data&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># sentinel monitor &lt;master-redis-name&gt; &lt;master-redis-ip&gt; &lt;master-redis-port&gt; &lt;quorum&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/2 + 1)，master才算真正失效</span>
</span></span><span style="display:flex;"><span>sentinel monitor mymaster 192.168.0.60 <span style="color:#ae81ff">6379</span> <span style="color:#ae81ff">2</span>   <span style="color:#75715e"># mymaster这个名字随便取，客户端访问时会用到</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>3、启动sentinel哨兵实例
</span></span><span style="display:flex;"><span>src/redis-sentinel sentinel-26379.conf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>4、查看sentinel的info信息
</span></span><span style="display:flex;"><span>src/redis-cli -p <span style="color:#ae81ff">26379</span>
</span></span><span style="display:flex;"><span>127.0.0.1:26379&gt;info
</span></span><span style="display:flex;"><span>可以看到Sentinel的info里已经识别出了redis的主从
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>5、可以自己再配置两个sentinel，端口26380和26381，注意上述配置文件里的对应数字都要修改
</span></span></code></pre></div><h3 id="jedis-连接哨兵">jedis 连接哨兵</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">JedisSentinelTest</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    JedisPoolConfig config <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> JedisPoolConfig();
</span></span><span style="display:flex;"><span>    config.<span style="color:#a6e22e">setMaxTotal</span>(20);
</span></span><span style="display:flex;"><span>    config.<span style="color:#a6e22e">setMaxIdle</span>(10);
</span></span><span style="display:flex;"><span>    config.<span style="color:#a6e22e">setMinIdle</span>(5);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    String masterName <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;mymaster&#34;</span>;
</span></span><span style="display:flex;"><span>    Set<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> sentinels <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>    sentinels.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> HostAndPort(<span style="color:#e6db74">&#34;192.168.0.60&#34;</span>,26379).<span style="color:#a6e22e">toString</span>());
</span></span><span style="display:flex;"><span>    sentinels.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> HostAndPort(<span style="color:#e6db74">&#34;192.168.0.60&#34;</span>,26380).<span style="color:#a6e22e">toString</span>());
</span></span><span style="display:flex;"><span>    sentinels.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> HostAndPort(<span style="color:#e6db74">&#34;192.168.0.60&#34;</span>,26381).<span style="color:#a6e22e">toString</span>());
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//JedisSentinelPool其实本质跟JedisPool类似，都是与redis主节点建立的连接池</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//JedisSentinelPool并不是说与sentinel建立的连接池，而是通过sentinel发现redis主节点并与其建立连接</span>
</span></span><span style="display:flex;"><span>    JedisSentinelPool jedisSentinelPool <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> JedisSentinelPool(masterName, sentinels, config, 3000, <span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>    Jedis jedis <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>      jedis <span style="color:#f92672">=</span> jedisSentinelPool.<span style="color:#a6e22e">getResource</span>();
</span></span><span style="display:flex;"><span>      System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(jedis.<span style="color:#a6e22e">set</span>(<span style="color:#e6db74">&#34;sentinel&#34;</span>, <span style="color:#e6db74">&#34;zhuge&#34;</span>));
</span></span><span style="display:flex;"><span>      System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(jedis.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;sentinel&#34;</span>));
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>      e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (jedis <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>        jedis.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="spring-boot-连接哨兵">spring-boot 连接哨兵</h3>
<p>引入依赖的jar包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&lt;groupId&gt;</span>org.springframework.boot<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&lt;artifactId&gt;</span>spring-boot-starter-data-redis<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&lt;groupId&gt;</span>org.apache.commons<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&lt;artifactId&gt;</span>commons-pool2<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>配置连接信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">server</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spring</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">redis</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">database</span>: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">timeout</span>: <span style="color:#ae81ff">3000</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">sentinel</span>:    <span style="color:#75715e">#哨兵模式</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">master</span>: <span style="color:#ae81ff">mymaster</span> <span style="color:#75715e">#主服务器所在集群名称</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">nodes</span>: <span style="color:#ae81ff">192.168.0.60</span>:<span style="color:#ae81ff">26379</span>,<span style="color:#ae81ff">192.168.0.60</span>:<span style="color:#ae81ff">26380</span>,<span style="color:#ae81ff">192.168.0.60</span>:<span style="color:#ae81ff">26381</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">lettuce</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">pool</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">max-idle</span>: <span style="color:#ae81ff">50</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">min-idle</span>: <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">max-active</span>: <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">max-wait</span>: <span style="color:#ae81ff">1000</span>
</span></span></code></pre></div><p>使用代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@RestController</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IndexController</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Logger logger <span style="color:#f92672">=</span> LoggerFactory.<span style="color:#a6e22e">getLogger</span>(IndexController.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Autowired</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> StringRedisTemplate stringRedisTemplate;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 测试节点挂了哨兵重新选举新的master节点，客户端是否能动态感知到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 新的master选举出来后，哨兵会把消息发布出去，客户端实际上是实现了一个消息监听机制，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 当哨兵把新master的消息发布出去，客户端会立马感知到新master的信息，从而动态切换访问的masterip
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @throws InterruptedException
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@RequestMapping</span>(<span style="color:#e6db74">&#34;/test_sentinel&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testSentinel</span>() <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                stringRedisTemplate.<span style="color:#a6e22e">opsForValue</span>().<span style="color:#a6e22e">set</span>(<span style="color:#e6db74">&#34;zhuge&#34;</span><span style="color:#f92672">+</span>i, i<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;设置key：&#34;</span><span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;zhuge&#34;</span> <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>                i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#a6e22e">sleep</span>(1000);
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">catch</span> (Exception e){
</span></span><span style="display:flex;"><span>                logger.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#34;错误：&#34;</span>, e);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="哨兵模式的缺点">哨兵模式的缺点</h3>
<p>虽然实现了自动故障转移，主节点挂了从节点会自动顶上去，但集群中只能有一个主节点提供服务，无法适应大量的数据存储，一个节点的内存毕竟的有限的，下面的集模式可以改进次问题，Redis集群模式可以实现数据分片，把不同的数据存储在不同的节点上，理论上可以做到无限大内存。</p>
<h2 id="redis-集群模式">Redis 集群模式</h2>
<p>Redis 集群至少需要3个主节点，一般需要给每个主节点配一个从节点。</p>
<p><img src="https://raw.githubusercontent.com/telzhou618/images/main/img01/1*1gUAG0m0infLs92uSpw9nA.png" alt="img"></p>
<h3 id="redis集群搭建">Redis集群搭建</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>第一步：在第一台机器的/usr/local下创建文件夹redis-cluster，然后在其下面分别创建2个文件夾如下
</span></span><span style="display:flex;"><span>（1）mkdir -p /usr/local/redis-cluster
</span></span><span style="display:flex;"><span>（2）mkdir <span style="color:#ae81ff">8001</span> <span style="color:#ae81ff">8004</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>第一步：把之前的redis.conf配置文件copy到8001下，修改如下内容：
</span></span><span style="display:flex;"><span>（1）daemonize yes
</span></span><span style="display:flex;"><span>（2）port 8001（分别对每个机器的端口号进行设置）
</span></span><span style="display:flex;"><span>（3）pidfile /var/run/redis_8001.pid  <span style="color:#75715e"># 把pid进程号写入pidfile配置的文件</span>
</span></span><span style="display:flex;"><span>（4）dir /usr/local/redis-cluster/8001/（指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据）
</span></span><span style="display:flex;"><span>（5）cluster-enabled yes（启动集群模式）
</span></span><span style="display:flex;"><span>（6）cluster-config-file nodes-8001.conf（集群节点信息文件，这里800x最好和port对应上）
</span></span><span style="display:flex;"><span>（7）cluster-node-timeout <span style="color:#ae81ff">10000</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">(</span>8<span style="color:#f92672">)</span><span style="color:#75715e"># bind 127.0.0.1（bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可）</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">(</span>9<span style="color:#f92672">)</span>protected-mode  no   （关闭保护模式）
</span></span><span style="display:flex;"><span> <span style="color:#f92672">(</span>10<span style="color:#f92672">)</span>appendonly yes
</span></span><span style="display:flex;"><span>如果要设置密码需要增加如下配置：
</span></span><span style="display:flex;"><span> <span style="color:#f92672">(</span>11<span style="color:#f92672">)</span>requirepass zhuge     <span style="color:#f92672">(</span>设置redis访问密码<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">(</span>12<span style="color:#f92672">)</span>masterauth zhuge      <span style="color:#f92672">(</span>设置集群节点间访问密码，跟上面一致<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>第三步：把修改后的配置文件，copy到8004，修改第2、3、4、6项里的端口号，可以用批量替换：
</span></span><span style="display:flex;"><span>:%s/源字符串/目的字符串/g 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>第四步：另外两台机器也需要做上面几步操作，第二台机器用8002和8005，第三台机器用8003和8006
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>第五步：分别启动6个redis实例，然后检查是否启动成功
</span></span><span style="display:flex;"><span>（1）/usr/local/redis-5.0.3/src/redis-server /usr/local/redis-cluster/800*/redis.conf
</span></span><span style="display:flex;"><span>（2）ps -ef | grep redis 查看是否启动成功
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>第六步：用redis-cli创建整个redis集群<span style="color:#f92672">(</span>redis5以前的版本集群是依靠ruby脚本redis-trib.rb实现<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 下面命令里的1代表为每个创建的主服务器节点创建一个从服务器节点</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 执行这条命令需要确认三台机器之间的redis实例要能相互访问，可以先简单把所有机器防火墙关掉，如果不关闭防火墙则需要打开redis服务端口和集群节点gossip通信端口16379(默认是在redis端口号上加1W)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 关闭防火墙</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># systemctl stop firewalld # 临时关闭防火墙</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># systemctl disable firewalld # 禁止开机启动</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 注意：下面这条创建集群的命令大家不要直接复制，里面的空格编码可能有问题导致创建集群不成功</span>
</span></span><span style="display:flex;"><span>（1）/usr/local/redis-5.0.3/src/redis-cli -a zhuge --cluster create --cluster-replicas <span style="color:#ae81ff">1</span> 192.168.0.61:8001 192.168.0.62:8002 192.168.0.63:8003 192.168.0.61:8004 192.168.0.62:8005 192.168.0.63:8006 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>第七步：验证集群：
</span></span><span style="display:flex;"><span>（1）连接任意一个客户端即可：./redis-cli -c -h -p <span style="color:#f92672">(</span>-a访问服务端密码，-c表示集群模式，指定ip地址和端口号）
</span></span><span style="display:flex;"><span>    如：/usr/local/redis-5.0.3/src/redis-cli -a zhuge -c -h 192.168.0.61 -p 800*
</span></span><span style="display:flex;"><span>（2）进行验证： cluster info（查看集群信息）、cluster nodes（查看节点列表）
</span></span><span style="display:flex;"><span>（3）进行数据操作验证
</span></span><span style="display:flex;"><span>（4）关闭集群则需要逐个进行关闭，使用命令：
</span></span><span style="display:flex;"><span>/usr/local/redis-5.0.3/src/redis-cli -a zhuge -c -h 192.168.0.60 -p 800* shutdown
</span></span></code></pre></div><h3 id="java-操作redis集群">java 操作Redis集群</h3>
<p>引入依赖</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;groupId&gt;</span>redis.clients<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;artifactId&gt;</span>jedis<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;version&gt;</span>2.9.0<span style="color:#f92672">&lt;/version&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>java 使用实例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">JedisClusterTest</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>      JedisPoolConfig config <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> JedisPoolConfig();
</span></span><span style="display:flex;"><span>      config.<span style="color:#a6e22e">setMaxTotal</span>(20);
</span></span><span style="display:flex;"><span>      config.<span style="color:#a6e22e">setMaxIdle</span>(10);
</span></span><span style="display:flex;"><span>      config.<span style="color:#a6e22e">setMinIdle</span>(5);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      Set<span style="color:#f92672">&lt;</span>HostAndPort<span style="color:#f92672">&gt;</span> jedisClusterNode <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;</span>HostAndPort<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>      jedisClusterNode.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> HostAndPort(<span style="color:#e6db74">&#34;192.168.0.61&#34;</span>, 8001));
</span></span><span style="display:flex;"><span>      jedisClusterNode.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> HostAndPort(<span style="color:#e6db74">&#34;192.168.0.62&#34;</span>, 8002));
</span></span><span style="display:flex;"><span>      jedisClusterNode.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> HostAndPort(<span style="color:#e6db74">&#34;192.168.0.63&#34;</span>, 8003));
</span></span><span style="display:flex;"><span>      jedisClusterNode.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> HostAndPort(<span style="color:#e6db74">&#34;192.168.0.61&#34;</span>, 8004));
</span></span><span style="display:flex;"><span>      jedisClusterNode.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> HostAndPort(<span style="color:#e6db74">&#34;192.168.0.62&#34;</span>, 8005));
</span></span><span style="display:flex;"><span>      jedisClusterNode.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> HostAndPort(<span style="color:#e6db74">&#34;192.168.0.63&#34;</span>, 8006));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      JedisCluster jedisCluster <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//connectionTimeout：指的是连接一个url的连接等待时间</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//soTimeout：指的是连接上一个url，获取response的返回等待时间</span>
</span></span><span style="display:flex;"><span>        jedisCluster <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> JedisCluster(jedisClusterNode, 6000, 5000, 10, <span style="color:#e6db74">&#34;zhuge&#34;</span>, config);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(jedisCluster.<span style="color:#a6e22e">set</span>(<span style="color:#e6db74">&#34;cluster&#34;</span>, <span style="color:#e6db74">&#34;zhuge&#34;</span>));
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(jedisCluster.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;cluster&#34;</span>));
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>        e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (jedisCluster <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>          jedisCluster.<span style="color:#a6e22e">close</span>();
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="spring-boot-操作redis集群">Spring-boot 操作Redis集群</h3>
<p>引入依赖</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&lt;groupId&gt;</span>org.springframework.boot<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&lt;artifactId&gt;</span>spring-boot-starter-data-redis<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&lt;groupId&gt;</span>org.apache.commons<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&lt;artifactId&gt;</span>commons-pool2<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>配置链接信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">server</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spring</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">redis</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">database</span>: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">timeout</span>: <span style="color:#ae81ff">3000</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">password</span>: <span style="color:#ae81ff">zhuge</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">cluster</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">nodes</span>: <span style="color:#ae81ff">192.168.0.61</span>:<span style="color:#ae81ff">8001</span>,<span style="color:#ae81ff">192.168.0.62</span>:<span style="color:#ae81ff">8002</span>,<span style="color:#ae81ff">192.168.0.63</span>:<span style="color:#ae81ff">8003</span>,<span style="color:#ae81ff">192.168.0.61</span>:<span style="color:#ae81ff">8004</span>,<span style="color:#ae81ff">192.168.0.62</span>:<span style="color:#ae81ff">8005</span>,<span style="color:#ae81ff">192.168.0.63</span>:<span style="color:#ae81ff">8006</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">lettuce</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">pool</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">max-idle</span>: <span style="color:#ae81ff">50</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">min-idle</span>: <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">max-active</span>: <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">max-wait</span>: <span style="color:#ae81ff">1000</span>
</span></span></code></pre></div><p>使用代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@RestController</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IndexController</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Logger logger <span style="color:#f92672">=</span> LoggerFactory.<span style="color:#a6e22e">getLogger</span>(IndexController.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Autowired</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> StringRedisTemplate stringRedisTemplate;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@RequestMapping</span>(<span style="color:#e6db74">&#34;/test_cluster&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testCluster</span>() <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>    stringRedisTemplate.<span style="color:#a6e22e">opsForValue</span>().<span style="color:#a6e22e">set</span>(<span style="color:#e6db74">&#34;zhuge&#34;</span>, <span style="color:#e6db74">&#34;666&#34;</span>);
</span></span><span style="display:flex;"><span>    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(stringRedisTemplate.<span style="color:#a6e22e">opsForValue</span>().<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;zhuge&#34;</span>));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="redis-集群原理分析">Redis 集群原理分析</h3>
<p>Redis Cluster 将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。</p>
<p>槽位定位算法</p>
<p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。HASH_SLOT = CRC16(key) mod 16384</p>
<h2 id="redis-核心原理">Redis 核心原理</h2>
<h3 id="单线程模型">单线程模型</h3>
<p>Redis之所以快是因为：1、基于内存操作，2-单线程没有上下文切换，3.基于epoll事件分发模型。所有的连接都放在一个队列里，注册到事件分发器上，如果有客户端发送数据，分发器或通知线程处理。</p>
<h3 id="简单动态字符串sds">简单动态字符串SDS</h3>
<p>Redis 没用使用C自带的字符串，二是自己定义一个，成为sds简单动态字符串。</p>
<p><img src="http://redisbook.com/_images/graphviz-72760f6945c3742eca0df91a91cc379168eda82d.png" alt="IMG"></p>
<ul>
<li>SDS源码</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sdshdr {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 记录 buf 数组中已使用字节的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 等于 SDS 所保存字符串的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> len;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 记录 buf 数组中未使用字节的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> free;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 字节数组，用于保存字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> buf[];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>比起 C 字符串， SDS 具有以下优点
<ul>
<li>常数复杂度获取字符串长度, O(1)。</li>
<li>杜绝缓冲区溢出，预先扩容，惰性缩容。</li>
<li>减少修改字符串长度时所需的内存重分配次数。</li>
<li>二进制安全。</li>
<li>兼容部分 C 字符串函数。</li>
</ul>
</li>
</ul>
<h3 id="链表">链表</h3>
<p>链表提供了高效的节点重排能力， 以及顺序性的节点访问方式， 并且可以通过增删节点来灵活地调整链表的长度。每个链表节点使用一个 <code>adlist.h/listNode</code> 结构来表示 ，多个 <code>listNode</code> 可以通过 <code>prev</code> 和 <code>next</code> 指针组成双端链表。</p>
<p><img src="https://raw.githubusercontent.com/telzhou618/images/main/img01/graphviz-167adfc2e52e078d4c0e3c8a9eddec54551602fb.png" alt="IMG"></p>
<ul>
<li>链表节点 listNode</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> listNode {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 前置节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> listNode <span style="color:#f92672">*</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 后置节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> listNode <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 节点的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value;
</span></span><span style="display:flex;"><span>} listNode;
</span></span></code></pre></div><ul>
<li>链表源码</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> list {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 表头节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    listNode <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 表尾节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    listNode <span style="color:#f92672">*</span>tail;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 链表所包含的节点数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 节点值复制函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>dup)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 节点值释放函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>free)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 节点值对比函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>match)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} list;
</span></span></code></pre></div><ul>
<li>用途：链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。</li>
</ul>
<h3 id="跳跃表">跳跃表</h3>
<p>Redis 的有序集合是用跳跃表实现的，跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的，跳跃表由 <code>redis.h/zskiplistNode</code> 和 <code>redis.h/zskiplist</code> 两个结构定义。</p>
<p><img src="http://redisbook.com/_images/graphviz-8fc5de396a5b52c3d0b1991a1e09558ad055dd86.png" alt="IMG"></p>
<ul>
<li>跳跃表节点 zskiplistNode</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> zskiplistNode {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 后退指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> zskiplistNode <span style="color:#f92672">*</span>backward;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 分值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">double</span> score;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 成员对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    robj <span style="color:#f92672">*</span>obj;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 层
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> zskiplistLevel {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 前进指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> zskiplistNode <span style="color:#f92672">*</span>forward;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 跨度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> span;
</span></span><span style="display:flex;"><span>    } level[];
</span></span><span style="display:flex;"><span>} zskiplistNode;
</span></span></code></pre></div><ul>
<li>跳跃表 zskiplist</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> zskiplist {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 表头节点和表尾节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> zskiplistNode <span style="color:#f92672">*</span>header, <span style="color:#f92672">*</span>tail;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 表中节点的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 表中层数最大的节点的层数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> level;
</span></span><span style="display:flex;"><span>} zskiplist;
</span></span></code></pre></div><ul>
<li>图 5-1 展示了一个跳跃表示例， 位于图片最左边的是 <code>zskiplist</code> 结构， 该结构包含以下属性：
<ul>
<li><code>header</code> ：指向跳跃表的表头节点。</li>
<li><code>tail</code> ：指向跳跃表的表尾节点。</li>
<li><code>level</code> ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li><code>length</code> ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>位于 <code>zskiplist</code> 结构右方的是四个 <code>zskiplistNode</code> 结构， 该结构包含以下属性：</p>
<ul>
<li>层（level）：节点中用 <code>L1</code> 、 <code>L2</code> 、 <code>L3</code> 等字样标记节点的各个层， <code>L1</code> 代表第一层， <code>L2</code> 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退（backward）指针：节点中用 <code>BW</code> 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：各个节点中的 <code>1.0</code> 、 <code>2.0</code> 和 <code>3.0</code> 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象（obj）：各个节点中的 <code>o1</code> 、 <code>o2</code> 和 <code>o3</code> 是节点所保存的成员对象。</li>
</ul>
</li>
<li>
<p>用途：Redis 的有序集合是用跳跃表实现的。</p>
</li>
</ul>
<h2 id="redis-常见问题及解决">Redis 常见问题及解决</h2>
<h3 id="缓存穿透">缓存穿透</h3>
<p>描述：查询了根本不存在的数据，导致请求打倒数据库。产生原因：自身业务代码或数据问题、恶意攻击、爬虫。</p>
<p>解决方案：1.缓存空对象。2.布隆过滤器。功能：布隆过期中不存在的对象一定不存，存在的不一定存在；特点：只能加数据数据，不能删数据。需要预先把所有数据初始化到布隆过滤器；Redis对应的产品：Redison。</p>
<h3 id="缓存失效击穿">缓存失效(击穿)</h3>
<p>描述：同一时间大量缓存失效导致请求直达数据库，造成数据库压力过大。</p>
<p>解决方案：在设置过期时间时加上一个随机值。</p>
<h3 id="缓存雪崩">缓存雪崩</h3>
<p>描述：缓存无法支持大量请求宕机，请求全部打到数据库。</p>
<p>解决方案：1.使用缓存高可用架构，如：Redis Sentinel 或 Redis Cluster。2.使用限流熔断并降级，如：Sentinel或Hystrix。3.提前演练，模拟宕机后做出一些应对情况。</p>
<h3 id="热点缓存失效重建">热点缓存失效重建</h3>
<p>描述：热点缓存失效，重建又比较好耗时，出现这种情况时大量请求会直达后端，有大量线程重建缓存，会造成后端压力过大。</p>
<p>解决方案：加一个分布式锁，只允许一个缓存重建缓存。</p>
<h3 id="缓存与数据库不一致">缓存与数据库不一致</h3>
<p>描述：在并发情况同时操作数据库和缓存可能导致缓存与数据库不一致。</p>
<p>解决方案：1.大部分场景是容忍短时间内缓存与数据库不一致的，只有设置过期时间即可，不能容忍不一致的可以加读写锁实现，但会牺牲一定的性能。</p>
<h2 id="redis-参考文档">Redis 参考文档</h2>
<ul>
<li>
<p>redis 官方文档： <a href="https://redis.io/documentation">https://redis.io/documentation</a></p>
</li>
<li>
<p>redis 设计与实现：<a href="http://redisbook.com/">http://redisbook.com/</a></p>
</li>
</ul>
</section>

  
  

  
  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://telzhou618.github.io/post/otter1/"
      ><span class="mr-1.5">←</span><span>Otter数据同步1 - 环境搭建</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://telzhou618.github.io/post/spring-aop/"
      ><span>Spring AOP 从入门到源码解析</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  
  

  
  

  
  
  <div class="mt-24" id="graphcomment"></div>
  <script type="text/javascript">
    var __semio__params = {
      graphcommentId: 'a42bc435-1a67-9bc8-2cde-72ec7ba0d2fb',
      behaviour: {
        
      },
      
    };

    function __semio__onload() {
      __semio__gc_graphlogin(__semio__params);
    }

    (function () {
      var gc = document.createElement('script');
      gc.type = 'text/javascript';
      gc.async = true;
      gc.onload = __semio__onload;
      gc.defer = true;
      gc.src =
        'https://integration.graphcomment.com/gc_graphlogin.js?' + Date.now();
      (
        document.getElementsByTagName('head')[0] ||
        document.getElementsByTagName('body')[0]
      ).appendChild(gc);
    })();
  </script>
  

  


  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="https://telzhou618.github.io">Home</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >✎ Paper</a
  >
</footer>

  </body>
</html>
